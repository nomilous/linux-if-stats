// Generated by CoffeeScript 1.6.3
var EOL, Emitter, dcopy, deferred, fs, local;

fs = require('fs');

Emitter = require('emitter');

dcopy = require('deep-copy');

deferred = require('decor').deferred;

EOL = require('os').EOL;

/*

IMPORTANT
--------- 

* poller skips if it catches it's tail

* emits 'poll' event with

    * `counters`  - Hash of counters
    * `timestamp` - Date
    * `deltas`    - Hash of counters, differece since preceding poll, **null on first poll**
    * `timespan`  - milliseconds since last poll, **null on first poll**

* emits 'error' event with he error

* start returns promise, resolves after first poll


KNOWN SUPPORTED LIST
--------------------

`cat /etc/lsb-release | grep DESCRIPTION`

* DISTRIB_DESCRIPTION="Ubuntu 12.04.3 LTS"
*/


local = {
  supported: process.platform === 'linux',
  metrics: ['rxBytes', 'rxPackets', 'rxErrs', 'rxDrop', 'rxFifo', 'rxFrame', 'rxCompressed', 'rxMulticast', 'txBytes', 'txPackets', 'txErrs', 'txDrop', 'txFifo', 'txColls', 'txCarrier', 'txCompressed'],
  pollTimer: void 0,
  pollActive: false,
  pollError: null,
  pollInterval: 1000,
  pollHistory: 500,
  buffer: [],
  emitter: new Emitter,
  poll: function() {
    var counters, curr, deltas, error, iface, metric, prev, previousCounters, previousTimestamp, reading, source, timespan, timestamp, _ref;
    if (local.pollActive) {
      return;
    }
    local.pollActive = true;
    counters = {};
    timestamp = new Date;
    deltas = null;
    timespan = null;
    try {
      _ref = local.buffer[0], previousCounters = _ref[0], previousTimestamp = _ref[1];
      timespan = timestamp - previousTimestamp;
      deltas = {};
    } catch (_error) {}
    reading = [counters, timestamp, deltas, timespan];
    try {
      source = fs.readFileSync('/proc/net/dev', 'utf8');
      source.split(EOL).slice(2).map(function(line) {
        var i, iface, ignore, keys, metrics, readings, _ref1;
        if (line.match(/^\s*$/)) {
          return;
        }
        _ref1 = line.match(/\s*(.*)\:(.*)/), ignore = _ref1[0], iface = _ref1[1], readings = _ref1[2];
        keys = local.metrics;
        i = -1;
        metrics = counters[iface] = {};
        return readings.match(/\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)/).map(function(value) {
          var key;
          if (!(key = keys[i++])) {
            return;
          }
          return metrics[key] = parseInt(value);
        });
      });
    } catch (_error) {
      error = _error;
      local.pollError = error;
      local.emitter.emit('error', error);
      local.pollActive = false;
      return;
    }
    local.pollError = null;
    if (deltas != null) {
      for (iface in counters) {
        deltas[iface] || (deltas[iface] = {});
        for (metric in counters[iface]) {
          prev = previousCounters[iface][metric];
          curr = counters[iface][metric];
          deltas[iface][metric] = curr - prev;
        }
      }
    }
    local.buffer.unshift(reading);
    while (local.buffer.length > local.pollHistory) {
      local.buffer.pop();
    }
    local.emitter.emit('poll', counters, timestamp, deltas, timespan);
    return local.pollActive = false;
  },
  start: deferred(function(action) {
    if (!local.supported) {
      return action.reject(new Error("Platform unsupported, expected: linux, got: " + process.platform));
    }
    if (local.pollTimer != null) {
      return action.resolve();
    }
    local.poll();
    local.pollTimer = setInterval(local.poll, local.pollInterval);
    return action.resolve();
  }),
  stop: function() {
    clearInterval(local.pollTimer);
    return local.pollTimer = void 0;
  },
  latest: function(opts, callback) {
    var counters, deltas, error, platform, result, timespan, timestamp, _ref;
    error = local.pollError;
    if (!local.supported) {
      platform = process.platform;
      error = new Error("Platform unsupported, expected: linux, got: " + platform);
      console.log(error);
    }
    try {
      _ref = local.buffer[0], counters = _ref[0], timestamp = _ref[1], deltas = _ref[2], timespan = _ref[3];
      result = {
        counters: counters,
        timestamp: timestamp,
        deltas: deltas,
        timespan: timespan
      };
    } catch (_error) {}
    if (typeof callback === 'function') {
      return callback(error, result);
    }
    if (!local.supported) {
      throw error;
    }
    return result;
  },
  config: function(opts, callback) {
    var key, params, previous, results;
    params = opts || {};
    if (opts.query != null) {
      params = opts.query;
    }
    results = {
      polling: local.pollTimer != null,
      interval: {
        value: local.pollInterval,
        changed: false,
        previous: null,
        error: null
      },
      history: {
        value: local.pollHistory,
        changed: false,
        previous: null,
        error: null
      }
    };
    for (key in params) {
      switch (key) {
        case 'interval':
          try {
            if (local.pollInterval === params[key]) {
              continue;
            }
            previous = local.pollInterval;
            local.pollInterval = parseInt(params[key]);
            results[key].changed = true;
            results[key].value = local.pollInterval;
            results[key].previous = previous;
            if (local.pollTimer != null) {
              local.stop();
              local.start();
            }
          } catch (_error) {}
          break;
        case 'history':
          try {
            if (parseInt(params[key]) < 2) {
              results[key].error = 'History buffer length cannot be less than 2';
              continue;
            }
            if (local.pollHistory === params[key]) {
              continue;
            }
            previous = local.pollHistory;
            local.pollHistory = parseInt(params[key]);
            results[key].changed = true;
            results[key].value = local.pollHistory;
            results[key].previous = previous;
          } catch (_error) {}
      }
    }
    if (typeof callback === 'function') {
      return callback(null, results);
    }
  }
};

/*

web exports
-----------

[vertex](https://github.com/nomilous/vertex)
*/


local.latest.$www = {};

local.config.$www = {};

/*

module / component exports
--------------------------
*/


module.exports = {
  latest: local.latest,
  start: local.start,
  stop: local.stop,
  config: local.config,
  on: function() {
    return local.emitter.on.apply(local.emitter, arguments);
  },
  once: function() {
    return local.emitter.once.apply(local.emitter, arguments);
  },
  off: function() {
    return local.emitter.off.apply(local.emitter, arguments);
  }
};

module.exports.test = function() {
  return local;
};
