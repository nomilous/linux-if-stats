// Generated by CoffeeScript 1.6.3
var EOL, fs, local;

fs = require('fs');

EOL = require('os').EOL;

/*

realized
--------

* internal polling loop per metricset might not be too smart
* more sensible perhaps for a calling parent loop to manage polling
* especially since the parent is likely also polling 
* with the resulting race condition therefore doing the foxtrot
* or playing musical chairs with itself in the mirror
* the music stops
* everybody either gets a chair, or bangs their head

moral of the story
------------------

* outside should not poll
* TODO: inside should publish events


local
-----

* this module's privates
* accessable for testing via `.test()`
* obviously therefore also accessable in general (if used, expect no consistancy between versions)

`local.reading`  - contains the latest reading from /proc/net/dev
`local.interval` - the interval of reading taking
`local.timer`    - the running timer loop reference
`local.polling`  - the poll is currently active
`local.poke`     - a purposeless additional comment referring, in jest at my excessive annotations, to a non existant property
`remote.fondle`  - not yet implemented on facebook, but just you wait...
*/


local = {
  reading: {},
  interval: 1000,
  timer: void 0,
  polling: false,
  current: function() {
    return local.reading;
  },
  poll: function() {
    var data;
    if (local.polling) {
      return;
    }
    local.polling = true;
    data = fs.readFileSync('/proc/net/dev');
    return data.split(EOL).slice(2).map(function(line) {
      var iface, ignore, keys, readings, _base, _ref;
      _ref = line.match(/\s*(.*)\:(.*)/), ignore = _ref[0], iface = _ref[1], readings = _ref[2];
      (_base = local.reading)[iface] || (_base[iface] = {});
      keys = ['ignore', 'rxBytes', 'rxPackets', 'rxErrs', 'rxDrop', 'xrFifo', 'rxFrame', 'rxCompressed', 'rxMulticast', 'txBytes', 'txPackets', 'txErrs', 'txDrop', 'txFifo', 'txColls', 'txCarrier', 'txCompressed'];
      readings.match(/\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)/).map(function(value) {
        var key;
        key = keys.shift();
        if (key === 'ignore') {
          return;
        }
        return local.reading[iface][key] = parseInt(value);
      });
      return local.polling = false;
    });
  },
  start: function() {
    var alreadyRunning;
    if (alreadyRunning = local.timer != null) {
      return;
    }
    return local.timer = setInterval(local.poll, local.interval);
  },
  stop: function() {
    clearInterval(local.timer);
    return local.timer = void 0;
  }
};

/*

web exports
-----------

* these functions become availiable over http if this component is grafted 
  onto a running [vertex](https://github.com/nomilous/vertex) routes tree
*/


local.current.$www = {};

/*

module / component exports
--------------------------
*/


module.exports = {
  current: local.current,
  start: local.start,
  stop: local.stop
};

module.exports.test = function() {
  return local;
};
