// Generated by CoffeeScript 1.6.3
var EOL, fs, local;

fs = require('fs');

EOL = require('os').EOL;

/*

realized
--------

* internal polling loop per metricset might not be too smart
* more sensible perhaps for a calling parent loop to manage polling
* especially since the parent is likely also polling 
* with the resulting race condition therefore doing the foxtrot
* or playing musical chairs with itself in the mirror
* the music stops
* everybody either gets a chair, or bangs their head

moral of the story
------------------

* outside should not poll
* TODO: inside should publish events


local
-----

* this module's privates
* accessable for testing via `.test()`
* obviously therefore also accessable in general (if used, expect no consistancy between versions)

`local.reading`  - contains the latest reading from /proc/net/dev
`local.interval` - the interval of reading taking
`local.timer`    - the running timer loop reference
`local.polling`  - the poll is currently active
`local.poke`     - a purposeless additional comment referring, in jest at my excessive annotations, to a non existant property
`remote.fondle`  - not yet implemented on facebook, but just you wait...
*/


local = {
  supported: true,
  reading: {},
  interval: 1000,
  timer: void 0,
  polling: false,
  current: function(opts, callback) {
    var error, platform;
    error = null;
    if (!local.supported) {
      platform = process.platform;
      error = new Error("Platform unsupported, expected: linux, got: " + platform);
    }
    if (typeof callback === 'function') {
      return callback(error, local.reading);
    }
    if (!local.supported) {
      throw error;
    }
    return local.reading;
  },
  poll: function() {
    var data, error;
    if (local.polling) {
      return;
    }
    local.polling = true;
    try {
      data = fs.readFileSync('/proc/net/dev', 'utf8');
    } catch (_error) {
      error = _error;
      local.supported = false;
      local.polling = false;
      return;
    }
    return data.split(EOL).slice(2).map(function(line) {
      var iface, ignore, keys, readings, _base, _ref;
      if (line.match(/^\s*$/)) {
        return;
      }
      _ref = line.match(/\s*(.*)\:(.*)/), ignore = _ref[0], iface = _ref[1], readings = _ref[2];
      (_base = local.reading)[iface] || (_base[iface] = {});
      keys = ['ignore', 'rxBytes', 'rxPackets', 'rxErrs', 'rxDrop', 'xrFifo', 'rxFrame', 'rxCompressed', 'rxMulticast', 'txBytes', 'txPackets', 'txErrs', 'txDrop', 'txFifo', 'txColls', 'txCarrier', 'txCompressed'];
      readings.match(/\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)/).map(function(value) {
        var key;
        key = keys.shift();
        if (key === 'ignore') {
          return;
        }
        return local.reading[iface][key] = parseInt(value);
      });
      return local.polling = false;
    });
  },
  start: function() {
    var alreadyRunning;
    if (alreadyRunning = local.timer != null) {
      return;
    }
    return local.timer = setInterval(local.poll, local.interval);
  },
  stop: function() {
    clearInterval(local.timer);
    return local.timer = void 0;
  },
  /*
  
  vertex friendlyness
  -------------------
  
  * this config() function can be exported on a running vertex (see web exports below)
  * web hit: `config?interval=10000` will call the function with `opts.query.interval`
  * obviously having to pass opts.query.interval would seem a bit obtuse for local use, 
    so the function does a bit of juggling about that
  * admittedly this need could be considered a bit of a design wrinkle
      * missing:  Alternative
      * lastseen: 29th Feb, 2017
  */

  config: function(opts, callback) {
    var key, oldVal, params, results;
    params = opts || {};
    if (opts.query != null) {
      params = opts.query;
    }
    results = {};
    for (key in params) {
      if (key === 'interval') {
        results[key] = {
          changed: false
        };
        try {
          oldVal = local.interval;
          local.interval = parseInt(params[key]);
          results[key] = {
            changed: true
          };
          results[key].oldVal = oldVal;
          results[key].newVal = local.interval;
          results[key].running = false;
          if (local.timer != null) {
            local.stop();
            local.start();
            results[key].running = true;
          }
        } catch (_error) {}
      }
    }
    if (typeof callback === 'function') {
      return callback(null, results);
    }
  }
};

/*

web exports
-----------

* these functions become availiable over http if this component is grafted 
  onto a running [vertex](https://github.com/nomilous/vertex) routes tree
* still much to be done with vertex
* eg. roles in the export config below does nothing yet
*/


local.current.$www = {};

local.config.$www = {
  roles: ['admin']
};

/*

module / component exports
--------------------------
*/


module.exports = {
  current: local.current,
  start: local.start,
  stop: local.stop,
  config: local.config
};

module.exports.test = function() {
  return local;
};
