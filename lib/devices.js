// Generated by CoffeeScript 1.6.3
var EOL, Emitter, deferred, fs, local;

fs = require('fs');

Emitter = require('emitter');

deferred = require('decor').deferred;

EOL = require('os').EOL;

/*

realized
--------

* internal polling loop per metricset might not be too smart
* more sensible perhaps for a calling parent loop to manage polling
* especially since the parent is likely also polling 
* with the resulting race condition therefore doing the foxtrot
* or playing musical chairs with itself in the mirror
* the music stops
* everybody either gets a chair, or bangs their head


moral of the story
------------------

* outside should not poll
* TODO: inside should publish events


realize (cont)
--------------

* most of the functionality here should be in a superclass, it will be repeated
* not so far fetched wanting to tinker with iface aliases, vlans, and such over a web api
* esp. eg. setting up a private vlan from some appserver vm onto some other dbserver vm on the fly


local
-----

* this module's privates
* accessable for testing via `.test()`
* obviously therefore also accessable in general (if used, expect no consistancy between versions)

`local.supported`    - platform is linux
`local.pollingError` - undefined unless the last poll errored
`local.reading`      - contains the latest reading from /proc/net/dev
`local.interval`     - the interval of reading taking
`local.timer`        - the running timer loop reference
`local.polling`      - the poll is currently active
`local.emitter`      - emits: 'poll' with latest counter values
`local.poke`         - a purposeless additional comment referring, in jest at my excessive annotations, to a non existant property
`remote.fondle`      - not yet implemented on facebook, but just you wait...
*/


local = {
  supported: process.platform === 'linux',
  pollingError: void 0,
  reading: {},
  interval: 1000,
  timer: void 0,
  polling: false,
  emitter: new Emitter,
  counters: function(opts, callback) {
    var error, platform;
    error = null;
    if (!local.supported) {
      platform = process.platform;
      error = new Error("Platform unsupported, expected: linux, got: " + platform);
      console.log(error);
    }
    if (typeof callback === 'function') {
      return callback(error, local.reading);
    }
    if (!local.supported) {
      throw error;
    }
    return local.reading;
  },
  poll: function() {
    var data, error;
    if (local.polling) {
      return;
    }
    local.polling = true;
    try {
      data = fs.readFileSync('/proc/net/dev', 'utf8');
    } catch (_error) {
      error = _error;
      local.pollingError = error;
      local.polling = false;
      return;
    }
    local.pollingError = void 0;
    return data.split(EOL).slice(2).map(function(line) {
      var iface, ignore, keys, readings, _base, _ref;
      if (line.match(/^\s*$/)) {
        return;
      }
      _ref = line.match(/\s*(.*)\:(.*)/), ignore = _ref[0], iface = _ref[1], readings = _ref[2];
      (_base = local.reading)[iface] || (_base[iface] = {});
      keys = ['ignore', 'rxBytes', 'rxPackets', 'rxErrs', 'rxDrop', 'xrFifo', 'rxFrame', 'rxCompressed', 'rxMulticast', 'txBytes', 'txPackets', 'txErrs', 'txDrop', 'txFifo', 'txColls', 'txCarrier', 'txCompressed'];
      readings.match(/\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)/).map(function(value) {
        var key;
        key = keys.shift();
        if (key === 'ignore') {
          return;
        }
        return local.reading[iface][key] = parseInt(value);
      });
      local.emitter.emit('poll');
      return local.polling = false;
    });
  },
  start: deferred(function(action) {
    if (!local.supported) {
      return action.reject(new Error("Platform unsupported, expected: linux, got: " + process.platform));
    }
    if (local.timer != null) {
      return action.resolve();
    }
    local.poll();
    local.timer = setInterval(local.poll, local.interval);
    return action.resolve();
  }),
  stop: function() {
    clearInterval(local.timer);
    return local.timer = void 0;
  },
  /*
  
  vertex friendlyness
  -------------------
  
  * this config() function can be exported on a running vertex (see web exports below)
  * web hit: `config?interval=10000` will call the function with `opts.query.interval`
  * obviously having to pass opts.query.interval would seem a bit obtuse for local use, 
    so the function does a bit of juggling about that
  * admittedly this need could be considered a bit of a design wrinkle
      * missing:  Alternative
      * lastseen: 29th Feb, 2017
  */

  config: function(opts, callback) {
    var key, params, previous, results;
    params = opts || {};
    if (opts.query != null) {
      params = opts.query;
    }
    results = {
      polling: local.timer != null,
      interval: {
        value: local.interval,
        changed: false,
        previous: null
      }
    };
    for (key in params) {
      if (key === 'interval') {
        results[key] = {
          changed: false
        };
        try {
          if (local.interval === params[key]) {
            continue;
          }
          previous = local.interval;
          local.interval = parseInt(params[key]);
          results[key].changed = true;
          results[key].value = local.interval;
          results[key].previous = previous;
          if (local.timer != null) {
            local.stop();
            local.start();
          }
        } catch (_error) {}
      }
    }
    if (typeof callback === 'function') {
      return callback(null, results);
    }
  }
};

/*

web exports
-----------

* these functions become availiable over http if this component is grafted 
  onto a running [vertex](https://github.com/nomilous/vertex) routes tree
* still much to be done with vertex
* eg. roles in the export config below does nothing yet
*/


local.counters.$www = {};

local.config.$www = {
  roles: ['admin']
};

/*

module / component exports
--------------------------
*/


module.exports = {
  counters: local.counters,
  start: local.start,
  stop: local.stop,
  config: local.config,
  on: function() {
    return local.emitter.on.apply(local.emitter, arguments);
  },
  once: function() {
    return local.emitter.once.apply(local.emitter, arguments);
  },
  off: function() {
    return local.emitter.off.apply(local.emitter, arguments);
  }
};

module.exports.test = function() {
  return local;
};
