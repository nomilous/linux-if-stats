// Generated by CoffeeScript 1.6.3
var EOL, Emitter, dcopy, deferred, fs, local;

fs = require('fs');

Emitter = require('emitter');

dcopy = require('deep-copy');

deferred = require('decor').deferred;

EOL = require('os').EOL;

/*

realized
--------

* internal polling loop per metricset might not be too smart
* more sensible perhaps for a calling parent loop to manage polling
* especially since the parent is likely also polling 
* with the resulting race condition therefore doing the foxtrot
* or playing musical chairs with itself in the mirror
* the music stops
* everybody either gets a chair, or bangs their head


moral of the story
------------------

* outside should not poll
* TODO: inside should publish events


realize (cont)
--------------

* most of the functionality here should be in a superclass, it will be repeated
* not so far fetched wanting to tinker with iface aliases, vlans, and such over a web api
* esp. eg. setting up a private vlan from some appserver vm onto some other dbserver vm on the fly


local
-----

* this module's privates
* accessable for testing via `.test()`
* obviously therefore also accessable in general (if used, expect no consistancy between versions)

`local.supported`      - platform is linux
`local.metrics`        - expected counters for each device listed in /proc/net/dev
`local.pollingActive`  - a poll is currently in process
`local.pollingError`   - undefined unless the last poll errored

`local.reading`        - contains the latest reading from /proc/net/dev
`local.interval`       - the interval of reading taking
`local.timer`          - the running timer loop reference

`local.pollTimestamp   - the most recen poll timestamp
`local.historyLength`  - keeps a history of readings
`local.history`        - Cambrian was fun, from an evolutionary progress prespective
                       - Also, i don't see much reason why range triggering can't be performed at the monitor agent
                       - Certainly lightens the load at the core
                       - First element in the history [] is the oldest
                       - Each element contains [timespan, reading] where timespan is milliseconds that elapsed till the next reading reading
`local.emitter`        - emits 'counters' event with latest counter values at each poll
                       - emits 'deltas' event including pollspan (milliseconds) at each poll
                       - IMPORTANT, poller skips if it catches it's tail
`local.poke`           - a purposeless additional comment referring, in jest at my excessive annotations, to a non existant property
`remote.fondle`        - not yet implemented on facebook, but just you wait...
*/


local = {
  supported: process.platform === 'linux',
  metrics: ['rxBytes', 'rxPackets', 'rxErrs', 'rxDrop', 'rxFifo', 'rxFrame', 'rxCompressed', 'rxMulticast', 'txBytes', 'txPackets', 'txErrs', 'txDrop', 'txFifo', 'txColls', 'txCarrier', 'txCompressed'],
  pollingActive: false,
  pollingError: void 0,
  reading: {},
  interval: 1000,
  timer: void 0,
  historyLength: 500,
  history: [],
  emitter: new Emitter,
  counters: function(opts, callback) {
    var error, platform;
    error = null;
    if (!local.supported) {
      platform = process.platform;
      error = new Error("Platform unsupported, expected: linux, got: " + platform);
      console.log(error);
    }
    if (typeof callback === 'function') {
      return callback(error, local.reading);
    }
    if (!local.supported) {
      throw error;
    }
    return local.reading;
  },
  poll: function() {
    var data, error, now, previous, timespan;
    if (local.pollingActive) {
      return;
    }
    local.pollingActive = true;
    now = new Date;
    if (local.pollTimestamp != null) {
      timespan = now - local.pollTimestamp;
      previous = dcopy(local.reading);
      local.history.push([timespan, previous]);
      while (local.history.length > local.historyLength) {
        local.history.shift();
      }
    }
    local.pollTimestamp = now;
    try {
      data = fs.readFileSync('/proc/net/dev', 'utf8');
    } catch (_error) {
      error = _error;
      local.pollingError = error;
      local.pollingActive = false;
      return;
    }
    local.pollingError = void 0;
    return data.split(EOL).slice(2).map(function(line) {
      var i, iface, ignore, keys, readings, _base, _ref;
      if (line.match(/^\s*$/)) {
        return;
      }
      _ref = line.match(/\s*(.*)\:(.*)/), ignore = _ref[0], iface = _ref[1], readings = _ref[2];
      keys = local.metrics;
      i = -1;
      (_base = local.reading)[iface] || (_base[iface] = {});
      readings.match(/\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)\s*(\d*)/).map(function(value) {
        var key;
        if (!(key = keys[i++])) {
          return;
        }
        return local.reading[iface][key] = parseInt(value);
      });
      local.emitter.emit('counters', local.reading, now);
      return local.pollingActive = false;
    });
  },
  start: deferred(function(action) {
    if (!local.supported) {
      return action.reject(new Error("Platform unsupported, expected: linux, got: " + process.platform));
    }
    if (local.timer != null) {
      return action.resolve();
    }
    local.poll();
    local.timer = setInterval(local.poll, local.interval);
    return action.resolve();
  }),
  stop: function() {
    clearInterval(local.timer);
    return local.timer = void 0;
  },
  /*
  
  vertex friendlyness
  -------------------
  
  * this config() function can be exported on a running vertex (see web exports below)
  * web hit: `config?interval=10000` will call the function with `opts.query.interval`
  * obviously having to pass opts.query.interval would seem a bit obtuse for local use, 
    so the function does a bit of juggling about that
  * admittedly this need could be considered a bit of a design wrinkle
      * missing:  Alternative
      * lastseen: 29th Feb, 2017
  */

  config: function(opts, callback) {
    var key, params, previous, results;
    params = opts || {};
    if (opts.query != null) {
      params = opts.query;
    }
    results = {
      polling: local.timer != null,
      interval: {
        value: local.interval,
        changed: false,
        previous: null
      },
      history: {
        value: local.historyLength,
        changed: false,
        previous: null
      }
    };
    for (key in params) {
      switch (key) {
        case 'interval':
          try {
            if (local.interval === params[key]) {
              continue;
            }
            previous = local.interval;
            local.interval = parseInt(params[key]);
            results[key].changed = true;
            results[key].value = local.interval;
            results[key].previous = previous;
            if (local.timer != null) {
              local.stop();
              local.start();
            }
          } catch (_error) {}
          break;
        case 'history':
          try {
            if (local.historyLength === params[key]) {
              continue;
            }
            previous = local.historyLength;
            local.historyLength = parseInt(params[key]);
            results[key].changed = true;
            results[key].value = local.historyLength;
            results[key].previous = previous;
          } catch (_error) {}
      }
    }
    if (typeof callback === 'function') {
      return callback(null, results);
    }
  }
};

/*

web exports
-----------

* these functions become availiable over http if this component is grafted 
  onto a running [vertex](https://github.com/nomilous/vertex) routes tree
* still much to be done with vertex
* eg. roles in the export config below does nothing yet
*/


local.counters.$www = {};

local.config.$www = {
  roles: ['admin']
};

/*

module / component exports
--------------------------
*/


module.exports = {
  counters: local.counters,
  start: local.start,
  stop: local.stop,
  config: local.config,
  on: function() {
    return local.emitter.on.apply(local.emitter, arguments);
  },
  once: function() {
    return local.emitter.once.apply(local.emitter, arguments);
  },
  off: function() {
    return local.emitter.off.apply(local.emitter, arguments);
  }
};

module.exports.test = function() {
  return local;
};
